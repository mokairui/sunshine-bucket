package com.sunshine.business01.infrastructure;

/**
 * @author Mokairui
 * @description 抽象工厂和工厂方法的之间的关系其实就是抽象工厂管理的是工厂方法, 也就是抽象工厂是又多个工厂方法组成的, 每个工厂方法是属于一个产品族的
 * @since 2023/10/29
 */
public interface Human {

    /* 
        上面的这三组方法还是原工厂方法模块里面的代码, 只是新增了一个性别的方法
                         人类
                           |
                --------------------------
                |           |            |
              黄种人       白种人       黑种人
                |           |            |
             --------     --------     -------
             |       |    |       |    |     |
        男性黄种人 女性黄种人 ......  ....
        
        对应上面的场景, 对于工厂方法来说现在需要增加一个性别的工厂, 是不是和桥接的图很像, 其实是一样的只是使用场景不一样, 在这里是创建
        也就是最终的目的是要创建出 '男性黄种人' 子类, 而桥接模式中是结构. 好了这里还是说明抽象工厂的实现
        
        实现: 这里目前发现有两种实现方案 
            抽象类继承实现: 一种是定义一个人类的总接口, 里面声明 人类的动作也就是 laugh(), cry(),talk() 以及新增的性别 sex() 抽象动作
        然后原来工厂方法的具体子类 黄种人, 白种人, 黑种人 改为抽象类实现 Human 接口分别实现 laugh(), cry(), talk()方法 这个现在就成功了 human 的工厂, 
        而性别工厂则作为 这个抽象类的具体子类, 这种是继承的方法实现
            对于每种抽象类继承的方式实现, 都会对应一种聚合的实现方式, 那么现在说所聚合的方式如何实现
            接口聚合实现: 定义总接口 人类 Human, 然后分别定义两个工厂方法也是接口 人类别的工厂 RaceFactory 以及性别的工厂 SexFactory,
        在人类别的接口中定义 laugh(), cry(), talk() 方法, 性别的工厂中定义 sex(), 这样同时也做到了接口的隔离, 在总接口 Human 中定义方法,
        方法内容就是调用createRace()方法创建对应 RaceFactory 接口的具体子类, 调用createSex()方法创建 SexFactory 的具体子类 
    */

    //人是愉快的，会笑的，本来是想用smile表示，想了一下laugh更合适，好长时间没有大笑了；
    void laugh();

    //人类还会哭，代表痛苦
    void cry();

    //人类会说话
    void talk();

    //定义性别
    void sex();

}
